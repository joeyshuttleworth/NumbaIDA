#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#include <ida/ida.h>
#include <sundials/sundials_types.h>
#include <sunlinsol/sunlinsol_dense.h>        /* access to dense SUNLinearSolver      */
#include <nvector/nvector_serial.h>

#include "IDAWrapper.hpp"

/* Used to store the users function.

   We're using the primitives instead of Sundials' types because the
   function is generated by Numba.
 */
void (*tmp_func)(double, double*, double*, double*, double*);

void (*tmp_jac)(double t, double* y, double * JJ);



int jacrob(realtype tt,  realtype cj,
           N_Vector yy, N_Vector yp, N_Vector resvec,
           SUNMatrix JJ, void *user_data,
           N_Vector tempv1, N_Vector tempv2, N_Vector tempv3)
{
  return(0);
}


/* Evaluate the users function (if it has been defined) */
static int translated_func(realtype t, N_Vector u, N_Vector du, N_Vector resval,
                       void *data){
  if(tmp_func == nullptr)
    return -1;
  else
    tmp_func((double) t, (double*) NV_DATA_S(u), (double*) NV_DATA_S(du),
             (double*) NV_DATA_S(resval), (double*) data);
}

// static int translated_jacobian_func(realtype tt,  realtype cj,
//                                     N_Vector yy, N_Vector yp, N_Vector resvec,
//                                     SUNMatrix JJ, void *user_data,
//                                     N_Vector tempv1, N_Vector tempv2, N_Vector tempv3){
//   if(tmp_jac == nullptr)
//     return -1;
//   else{
//     tmp_jac((double t), (double*) yy->content)
//   }
// }


static int check_retval(void *returnvalue, const char *funcname, int opt)
{
  int *retval;
  /* Check if SUNDIALS function returned NULL pointer - no memory allocated */
  if (opt == 0 && returnvalue == NULL) {
    fprintf(stderr,
            "\nSUNDIALS_ERROR: %s() failed - returned NULL pointer\n\n",
            funcname);
    return(1);
  } else if (opt == 1) {
    /* Check if retval < 0 */
    retval = (int *) returnvalue;
    if (*retval < 0) {
      fprintf(stderr,
              "\nSUNDIALS_ERROR: %s() failed with retval = %d\n\n",
              funcname, *retval);
      return(1);
    }
  } else if (opt == 2 && returnvalue == NULL) {
    /* Check if function returned NULL pointer - no memory allocated */
    fprintf(stderr,
            "\nMEMORY_ERROR: %s() failed - returned NULL pointer\n\n",
            funcname);
    return(1);
  }

  return(0);
}


extern "C"{
#include <unistd.h>

  void ida_wrapper(void (*F_func)(double, double*, double*, double*, double*),
                   int neq, double* u0, double* du0, double* res,
                   double* data, int data_size, int nt, double* teval,
                   double* usol, double rtol,
                   double* avtol, int* success){

    printf("Initialising IDA solver... \n");

    int retval;
    SUNContext ctx;

    retval = SUNContext_Create(NULL, &ctx);
    void* ida_mem = IDACreate(ctx);

    if(check_retval((void *)ida_mem, "IDACreate", 0)){
      *success = -1;
      printf("Failed to create IDA solver\n");
      return;
    }

    N_Vector y = N_VNew_Serial(neq, ctx);
    N_Vector dydt = N_VNew_Serial(neq, ctx);

    /* Set user config data */
    retval = IDASetUserData(ida_mem, data);
    printf("Set user data \n");

    *success = 1;

    for(int i = 0; i < neq; i++){
      NV_Ith_S(y, i) = u0[i];
      NV_Ith_S(dydt, i) = du0[i];
      usol[i] = u0[i];
      printf("%f ", u0[i]);
    }
    printf("\n");

    printf("Copied over initial conditions \n");

    double t = teval[0];
    double tout;

    tmp_func = F_func;
    // tmp_jac  = F_jac;

    retval = IDAInit(ida_mem, &translated_func, teval[0], y, dydt);

    printf("Setting tolerances... \n");

    N_Vector nvec_avtol;
    nvec_avtol = N_VNew_Serial(neq, ctx);
    NV_DATA_S(nvec_avtol) = avtol;

    retval = IDASVtolerances(ida_mem, rtol, nvec_avtol);
    if(check_retval(&retval, "IDASVtolerances", 1)){
      *success = -1;
      return;
    }

    /* Create dense SUNMatrix for use in linear solves */
    SUNMatrix A = SUNDenseMatrix(neq, neq, ctx);
    if(check_retval((void *)A, "SUNDenseMatrix", 0)){*success = -1; return;}

    /* Create dense SUNLinearSolver object */
    SUNLinearSolver LS = SUNLinSol_Dense(y, A, ctx);
    if(check_retval((void *)LS, "SUNLinSol_Dense", 0)){*success = -1; return;}

    /* Attach the matrix and linear solver */
    retval = IDASetLinearSolver(ida_mem, LS, A);
    if(check_retval(&retval, "IDASetLinearSolver", 1)){*success = -1; return;}

    /* Set the user-supplied Jacobian routine */
    // retval = IDASetJacFn(ida_mem, jacrob);
    // if(check_retval(&retval, "IDASetJacFn", 1)){*success=-1; return;}

    printf("Running IDA solve... \n");

    for (int i = 1; i < nt; i++){
      printf("Doing integration step %i\n", i);
      if (teval[i] < teval[i-1]){
        *success = 0;
        return;
      }

      tout = teval[i];

      for(int i = 0; i < neq; i++){
        printf("%f ", NV_Ith_S(y, i));
      }
      printf("\n");

      /* call integrator */
      printf("Calling integrator for time %f starting at time %f\n", tout, t);
      retval = IDASolve(ida_mem, tout, &t, y, dydt, IDA_NORMAL);

      printf("Retval was %i\n", retval);
      if (retval != 0){
        // there is a problem!
        *success = retval;
        return;
      }
      // save solution
      for (int j = 0; j < neq; j++){
        usol[j + neq*i] = NV_Ith_S(y, j);
      }
    }
    IDAFree(&ida_mem);
  }
}
